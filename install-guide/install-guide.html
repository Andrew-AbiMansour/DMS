<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Installation guide for GROMACS 5.0</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">Installation guide for GROMACS 5.0</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#building-gromacs">Building GROMACS</a></li>
<li><a href="#quick-and-dirty-installation">Quick and dirty installation</a></li>
<li><a href="#typical-gromacs-installation">Typical GROMACS installation</a></li>
<li><a href="#building-older-gromacs-versions">Building older GROMACS versions</a></li>
<li><a href="#prerequisites">Prerequisites</a><ul>
<li><a href="#platform">Platform</a></li>
<li><a href="#compiler">Compiler</a></li>
<li><a href="#compiling-with-parallelization-options">Compiling with parallelization options</a><ul>
<li><a href="#gpu-support">GPU support</a></li>
<li><a href="#mpi-support">MPI support</a></li>
</ul></li>
<li><a href="#cmake">CMake</a></li>
<li><a href="#fast-fourier-transform-library">Fast Fourier Transform library</a><ul>
<li><a href="#fftw">FFTW</a></li>
<li><a href="#mkl">MKL</a></li>
</ul></li>
<li><a href="#optional-build-components">Optional build components</a></li>
</ul></li>
<li><a href="#doing-a-build-of-gromacs">Doing a build of GROMACS</a><ul>
<li><a href="#configuring-with-cmake">Configuring with CMake</a><ul>
<li><a href="#using-cmake-command-line-options">Using CMake command-line options</a></li>
<li><a href="#simd-support">SIMD support</a></li>
<li><a href="#cmake-advanced-options">CMake advanced options</a></li>
<li><a href="#helping-cmake-find-the-right-librariesheadersprograms">Helping CMake find the right libraries/headers/programs</a></li>
<li><a href="#native-gpu-acceleration">Native GPU acceleration</a></li>
<li><a href="#static-linking">Static linking</a></li>
<li><a href="#portability-aspects">Portability aspects</a></li>
<li><a href="#linear-algebra-libraries">Linear algebra libraries</a></li>
<li><a href="#changing-the-names-of-gromacs-binaries-and-libraries">Changing the names of GROMACS binaries and libraries</a></li>
</ul></li>
<li><a href="#building-gromacs-1">Building GROMACS</a><ul>
<li><a href="#building-only-mdrun">Building only mdrun</a></li>
</ul></li>
<li><a href="#installing-gromacs">Installing GROMACS</a></li>
<li><a href="#getting-access-to-gromacs-after-installation">Getting access to GROMACS after installation</a></li>
<li><a href="#testing-gromacs-for-correctness">Testing GROMACS for correctness</a></li>
<li><a href="#testing-gromacs-for-performance">Testing GROMACS for performance</a></li>
<li><a href="#having-difficulty">Having difficulty?</a></li>
</ul></li>
<li><a href="#special-instructions-for-some-platforms">Special instructions for some platforms</a><ul>
<li><a href="#building-on-windows">Building on Windows</a></li>
<li><a href="#building-on-cray">Building on Cray</a></li>
<li><a href="#building-on-bluegene">Building on BlueGene</a><ul>
<li><a href="#bluegeneq">BlueGene/Q</a></li>
<li><a href="#bluegenep">BlueGene/P</a></li>
<li><a href="#fujitsu-primehpc">Fujitsu PRIMEHPC</a></li>
<li><a href="#intel-xeon-phi">Intel Xeon Phi</a></li>
</ul></li>
</ul></li>
<li><a href="#tested-platforms">Tested platforms</a></li>
</ul>
</div>
<h1 id="building-gromacs"><a href="#building-gromacs">Building GROMACS</a></h1>
<p>These instructions pertain to building GROMACS 5.0. Up-to-date installation instructions may be found at <a href="http://www.gromacs.org/Documentation/Installation_Instructions">http://www.gromacs.org/Documentation/Installation_Instructions</a>.</p>
<h1 id="quick-and-dirty-installation"><a href="#quick-and-dirty-installation">Quick and dirty installation</a></h1>
<ol style="list-style-type: decimal">
<li>Get the latest version of your C and C++ compilers.</li>
<li>Check that you have CMake version 2.8.8 or later.</li>
<li>Get and unpack the latest version of the GROMACS tarball.</li>
<li>Make a separate build directory and change to it.</li>
<li>Run <code>cmake</code> with the path to the source as an argument</li>
<li>Run <code>make</code> and <code>make install</code></li>
</ol>
<p>Or, as a sequence of commands to execute:</p>
<pre><code>tar xfz gromacs-5.0.tar.gz
cd gromacs-5.0
mkdir build
cd build
cmake .. -DGMX_BUILD_OWN_FFTW=ON
make
sudo make install
source /usr/local/gromacs/bin/GMXRC</code></pre>
<p>This will download and build first the prerequisite FFT library followed by GROMACS. If you already have FFTW installed, you can remove that argument to <code>cmake</code>. Overall, this build of GROMACS will be correct and reasonably fast on the machine upon which <code>cmake</code> ran. If you want to get the maximum value for your hardware with GROMACS, you will have to read further. Sadly, the interactions of hardware, libraries, and compilers are only going to continue to get more complex.</p>
<h1 id="typical-gromacs-installation"><a href="#typical-gromacs-installation">Typical GROMACS installation</a></h1>
<p>As above, and with further details below, but you should consider using the following <a href="#using-cmake-command-line-options">CMake options</a> with the appropriate value instead of <code>xxx</code> :</p>
<ul>
<li><code>-DCMAKE_C_COMPILER=xxx</code> equal to the name of the C99 <a href="#compiler">compiler</a> you wish to use (or the environment variable <code>CC</code>)</li>
<li><code>-DCMAKE_CXX_COMPILER=xxx</code> equal to the name of the C++98 <a href="#compiler">compiler</a> you wish to use (or the environment variable <code>CXX</code>)</li>
<li><code>-DGMX_MPI=on</code> to build using an <a href="#mpi-support">MPI</a> wrapper compiler</li>
<li><code>-DGMX_GPU=on</code> to build using nvcc to run with an NVIDIA <a href="#native-gpu-acceleration">GPU</a></li>
<li><code>-DGMX_SIMD=xxx</code> to specify the level of <a href="#simd-support">SIMD support</a> of the node on which <code>mdrun</code> will run</li>
<li><code>-DGMX_BUILD_MDRUN_ONLY=on</code> to <a href="#building-only-mdrun">build only the <code>mdrun</code> binary</a>, e.g. for compute cluster back-end nodes</li>
<li><code>-DGMX_DOUBLE=on</code> to run GROMACS in double precision (slower, and not normally useful)</li>
<li><code>-DCMAKE_PREFIX_PATH=xxx</code> to add a non-standard location for CMake to <a href="#helping-cmake-find-the-right-librariesheadersprograms">search for libraries</a></li>
<li><code>-DCMAKE_INSTALL_PREFIX=xxx</code> to install GROMACS to a non-standard location (default <code>/usr/local/gromacs</code>)</li>
<li><code>-DBUILD_SHARED_LIBS=off</code> to turn off the building of <a href="#static-linking">shared libraries</a></li>
<li><code>-DGMX_FFT_LIBRARY=xxx</code> to select whether to use <code>fftw</code>, <code>mkl</code> or <code>fftpack</code> libraries for <a href="#fast-fourier-transform-library">FFT support</a></li>
<li><code>-DCMAKE_BUILD_TYPE=Debug</code> to build GROMACS in debug mode</li>
</ul>
<h1 id="building-older-gromacs-versions"><a href="#building-older-gromacs-versions">Building older GROMACS versions</a></h1>
<p>For installation instructions for old GROMACS versions, see the documentation at <a href="http://www.gromacs.org/Documentation/Installation_Instructions_4.5">http://www.gromacs.org/Documentation/Installation_Instructions_4.5</a> and <a href="http://www.gromacs.org/Documentation/Installation_Instructions_4.6">http://www.gromacs.org/Documentation/Installation_Instructions_4.6</a></p>
<h1 id="prerequisites"><a href="#prerequisites">Prerequisites</a></h1>
<h2 id="platform"><a href="#platform">Platform</a></h2>
<p>GROMACS can be compiled for many operating systems and architectures. These include any distribution of Linux, Mac OS X or Windows, and architectures including x86, AMD64/x86-64, PPC, ARM v7 and SPARC VIII.</p>
<h2 id="compiler"><a href="#compiler">Compiler</a></h2>
<p>Technically, GROMACS can be compiled on any platform with an ANSI C99 and C++98 compiler, and their respective standard C/C++ libraries. Getting good performance on an OS and architecture requires choosing a good compiler. In practice, many compilers struggle to do a good job optimizing the GROMACS architecture-optimized SIMD kernels.</p>
<p>For best performance, the GROMACS team strongly recommends you get the most recent version of your preferred compiler for your platform. There is a large amount of GROMACS code that depends on effective compiler optimization to get high performance. This makes GROMACS performance sensitive to the compiler used, and the binary will often only work on the hardware for which it is compiled.</p>
<ul>
<li><p>In particular, GROMACS includes a lot of explicit SIMD (single instruction, multiple data) optimization that can use assembly instructions available on most modern processors. This can have a substantial effect on performance, but for recent processors you also need a similarly recent compiler that includes support for the corresponding SIMD instruction set to get this benefit. The configuration does a good job at detecting this, and you will usually get warnings if GROMACS and your hardware support a more recent instruction set than your compiler.</p></li>
<li><p>On Intel-based x86 hardware, we recommend you to use the GNU compilers version 4.7 or later or Intel compilers version 12 or later for best performance. The Intel compiler has historically been better at instruction scheduling, but recent gcc versions have proved to be as fast or sometimes faster than Intel.</p></li>
<li><p>The Intel and GNU compilers produce much faster GROMACS executables than the PGI and Cray compilers.</p></li>
<li><p>On AMD-based x86 hardware up through the &quot;K10&quot; microarchitecture (&quot;Family 10h&quot;) Thuban/Magny-Cours architecture (e.g. Opteron 6100-series processors), it is worth using the Intel compiler for better performance, but gcc version 4.7 and later are also reasonable.</p></li>
<li><p>On the AMD Bulldozer architecture (Opteron 6200), AMD introduced fused multiply-add instructions and an &quot;FMA4&quot; instruction format not available on Intel x86 processors. Thus, on the most recent AMD processors you want to use gcc version 4.7 or later for best performance! The Intel compiler will only generate code for the subset also supported by Intel processors, and that is significantly slower.</p></li>
<li><p>If you are running on Mac OS X, the best option is the Intel compiler. Both clang and gcc will work, but they produce lower performance and each have some shortcomings. Current Clang does not support OpenMP. This may change when clang 3.5 becomes available.</p></li>
<li><p>For all non-x86 platforms, your best option is typically to use the vendor's default or recommended compiler, and check for specialized information below.</p></li>
</ul>
<h2 id="compiling-with-parallelization-options"><a href="#compiling-with-parallelization-options">Compiling with parallelization options</a></h2>
<p>GROMACS can run in parallel on multiple cores of a single workstation using its built-in thread-MPI. No user action is required in order to enable this.</p>
<h3 id="gpu-support"><a href="#gpu-support">GPU support</a></h3>
<p>If you wish to use the excellent native GPU support in GROMACS, NVIDIA's <a href="http://www.nvidia.com/object/cuda_home_new.html">CUDA</a> version 4.0 software development kit is required, and the latest version is strongly encouraged. NVIDIA GPUs with at least NVIDIA compute capability 2.0 are required, e.g. Fermi or Kepler cards. You are strongly recommended to get the latest CUDA version and driver supported by your hardware, but beware of possible performance regressions in newer CUDA versions on older hardware. Note that while some CUDA compilers (nvcc) might not officially support recent versions of gcc as the back-end compiler, we still recommend that you at least use a gcc version recent enough to get the best SIMD support for your CPU, since GROMACS always runs some code on the CPU. It is most reliable to use the same C++ compiler version for GROMACS code as used as the back-end compiler for nvcc, but it could be faster to mix compiler versions to suit particular contexts.</p>
<h3 id="mpi-support"><a href="#mpi-support">MPI support</a></h3>
<p>If you wish to run in parallel on multiple machines across a network, you will need to have</p>
<ul>
<li>an MPI library installed that supports the MPI 1.3 standard, and</li>
<li>wrapper compilers that will compile code using that library.</li>
</ul>
<p>The GROMACS team recommends <a href="http://www.open-mpi.org">OpenMPI</a> version 1.6 (or higher), <a href="http://www.mpich.org">MPICH</a> version 1.4.1 (or higher), or your hardware vendor's MPI installation. The most recent version of either of these is likely to be the best. More specialized networks might depend on accelerations only available in the vendor's library. <a href="http://www.lam-mpi.org">LAMMPI</a> might work, but since it has been deprecated for years, it is not supported.</p>
<p>Often <a href="http://en.wikipedia.org/wiki/OpenMP">OpenMP</a> parallelism is an advantage for GROMACS, but support for this is generally built into your compiler and detected automatically.</p>
<p>In summary, for maximum performance you will need to examine how you will use GROMACS, what hardware you plan to run on, and whether you can afford a non-free compiler for slightly better performance. Unfortunately, the only way to find out is to test different options and parallelization schemes for the actual simulations you want to run. You will still get <em>good</em>, performance with the default build and runtime options, but if you truly want to push your hardware to the performance limit, the days of just blindly starting programs with <code>mdrun</code> are gone.</p>
<h2 id="cmake"><a href="#cmake">CMake</a></h2>
<p>GROMACS 5.0 uses the CMake build system, and requires version 2.8.8 or higher. Lower versions will not work. You can check whether CMake is installed, and what version it is, with <code>cmake --version</code>. If you need to install CMake, then first check whether your platform's package management system provides a suitable version, or visit <a href="http://www.cmake.org/cmake/help/install.html">http://www.cmake.org/cmake/help/install.html</a> for pre-compiled binaries, source code and installation instructions. The GROMACS team recommends you install the most recent version of CMake you can.</p>
<h2 id="fast-fourier-transform-library"><a href="#fast-fourier-transform-library">Fast Fourier Transform library</a></h2>
<p>Many simulations in GROMACS make extensive use of fast Fourier transforms, and a software library to perform these is always required. We recommend <a href="http://www.fftw.org">FFTW</a> (version 3 or higher only) or <a href="http://software.intel.com/en-us/intel-mkl">Intel MKL</a>. The choice of library can be set with <code>cmake -DGMX_FFT_LIBRARY=&lt;name&gt;</code>, where <code>&lt;name&gt;</code> is one of <code>fftw</code>, <code>mkl</code>, or <code>fftpack</code>. FFTPACK is bundled with GROMACS as a fallback, and is acceptable if mdrun performance is not a priority.</p>
<h3 id="fftw"><a href="#fftw">FFTW</a></h3>
<p>FFTW is likely to be available for your platform via its package management system, but there can be compatibility and significant performance issues associated with these packages. In particular, GROMACS simulations are normally run in &quot;mixed&quot; floating-point precision, which is suited for the use of single precision in FFTW. The default FFTW package is normally in double precision, and good compiler options to use for FFTW when linked to GROMACS may not have been used. Accordingly, the GROMACS team recommends either</p>
<ul>
<li>that you permit the GROMACS installation to download and build FFTW from source automatically for you (use <code>cmake -DGMX_BUILD_OWN_FFTW=ON</code>), or</li>
<li>that you build FFTW from the source code.</li>
</ul>
<p>Note that the GROMACS-managed download of the FFTW tarball has a slight chance of posing a security risk. If you use this option, you will see a warning that advises how you can eliminate this risk (before the opportunity has arisen).</p>
<p>If you build FFTW from source yourself, get the most recent version and follow its <a href="http://www.fftw.org/doc/Installation-and-Customization.html#Installation-and-Customization">installation guide</a>. Choose the precision for FFTW (i.e. single or float vs. double) to match whether you will later use mixed or double precision for GROMACS. There is no need to compile FFTW with threading or MPI support, but it does no harm. On x86 hardware, compile <em>only</em> with <code>--enable-sse2</code> (regardless of precision) even if your processors can take advantage of AVX extensions. Since GROMACS uses fairly short transform lengths we do not benefit from the FFTW AVX acceleration, and because of memory system performance limitations, it can even degrade GROMACS performance by around 20%. There is no way for GROMACS to limit the use to SSE2 SIMD at run time if AVX support has been compiled into FFTW, so you need to set this at compile time.</p>
<h3 id="mkl"><a href="#mkl">MKL</a></h3>
<p>Using MKL with the Intel Compilers version 11 or higher is very simple. Set up your compiler environment correctly, perhaps with a command like <code>source /path/to/compilervars.sh intel64</code> (or consult your local documentation). Then set <code>-DGMX_FFT_LIBRARY=mkl</code> when you run cmake. In this case, GROMACS will also use MKL for BLAS and LAPACK (see <a href="#linear-algebra-libraries">linear algebra libraries</a>). Generally, there is no advantage in using MKL with GROMACS, and FFTW is often faster.</p>
<p>Otherwise, you can get your hands dirty and configure MKL by setting</p>
<pre><code>-DGMX_FFT_LIBRARY=mkl
-DMKL_LIBRARIES=&quot;/full/path/to/libone.so;/full/path/to/libtwo.so&quot;
-DMKL_INCLUDE_DIR=&quot;/full/path/to/mkl/include&quot;</code></pre>
<p>where the full list (and order!) of libraries you require are found in Intel's MKL documentation for your system.</p>
<h2 id="optional-build-components"><a href="#optional-build-components">Optional build components</a></h2>
<ul>
<li>Compiling to run on NVIDIA GPUs requires CUDA</li>
<li>An external Boost library can be used to provide better implementation support for smart pointers and exception handling, but the GROMACS source bundles a subset of Boost 1.55.0 as a fallback</li>
<li>Hardware-optimized BLAS and LAPACK libraries are useful for a few of the GROMACS utilities focused on normal modes and matrix manipulation, but they do not provide any benefits for normal simulations. Configuring these are discussed at <a href="#linear-algebra-libraries">linear algebra libraries</a>.</li>
<li>The built-in GROMACS trajectory viewer <code>gmx view</code> requires X11 and Motif/Lesstif libraries and header files. You may prefer to use third-party software for visualization, such as <a href="http://www.ks.uiuc.edu/Research/vmd">VMD</a> or <a href="http://www.pymol.org">PyMOL</a>.</li>
<li>An external TNG library for trajectory-file handling can be used, but TNG 1.6 is bundled in the GROMACS source already</li>
<li>zlib is used by TNG for compressing some kinds of trajectory data</li>
<li>Running the GROMACS test suite requires libxml2</li>
<li>Building the GROMACS documentation requires ImageMagick, pdflatex, bibtex, doxygen and pandoc.</li>
<li>The GROMACS utility programs often write data files in formats suitable for the Grace plotting tool, but it is straightforward to use these files in other plotting programs, too.</li>
</ul>
<h1 id="doing-a-build-of-gromacs"><a href="#doing-a-build-of-gromacs">Doing a build of GROMACS</a></h1>
<p>This section will cover a general build of GROMACS with CMake, but it is not an exhaustive discussion of how to use CMake. There are many resources available on the web, which we suggest you search for when you encounter problems not covered here. The material below applies specifically to builds on Unix-like systems, including Linux, and Mac OS X. For other platforms, see the specialist instructions below.</p>
<h2 id="configuring-with-cmake"><a href="#configuring-with-cmake">Configuring with CMake</a></h2>
<p>CMake will run many tests on your system and do its best to work out how to build GROMACS for you. If your build machine is the same as your target machine, then you can be sure that the defaults will be pretty good. The build configuration will for instance attempt to detect the specific hardware instructions available in your processor. However, if you want to control aspects of the build, or you are compiling on a cluster head node for back-end nodes with a different architecture, there are plenty of things you can set manually.</p>
<p>The best way to use CMake to configure GROMACS is to do an &quot;out-of-source&quot; build, by making another directory from which you will run CMake. This can be outside the source directory, or a subdirectory of it. It also means you can never corrupt your source code by trying to build it! So, the only required argument on the CMake command line is the name of the directory containing the <code>CMakeLists.txt</code> file of the code you want to build. For example, download the source tarball and use</p>
<pre><code>$ tar xfz gromacs-5.0.tgz
$ cd gromacs-5.0
$ mkdir build-gromacs
$ cd build-gromacs
$ cmake ..</code></pre>
<p>You will see <code>cmake</code> report a sequence of results of tests and detections done by the GROMACS build system. These are written to the <code>cmake</code> cache, kept in <code>CMakeCache.txt</code>. You can edit this file by hand, but this is not recommended because you could make a mistake. You should not attempt to move or copy this file to do another build, because file paths are hard-coded within it. If you mess things up, just delete this file and start again with <code>cmake</code>.</p>
<p>If there is a serious problem detected at this stage, then you will see a fatal error and some suggestions for how to overcome it. If you are not sure how to deal with that, please start by searching on the web (most computer problems already have known solutions!) and then consult the gmx-users mailing list. There are also informational warnings that you might like to take on board or not. Piping the output of <code>cmake</code> through <code>less</code> or <code>tee</code> can be useful, too.</p>
<p>Once <code>cmake</code> returns, you can see all the settings that were chosen and information about them by using e.g. the curses interface</p>
<pre><code>$ ccmake ..</code></pre>
<p>You can actually use <code>ccmake</code> (available on most Unix platforms, if the curses library is supported) directly in the first step, but then most of the status messages will merely blink in the lower part of the terminal rather than be written to standard out. Most platforms including Linux, Windows, and Mac OS X even have native graphical user interfaces for <code>cmake</code>, and it can create project files for almost any build environment you want (including Visual Studio or Xcode). Check out <a href="http://www.cmake.org/cmake/help/runningcmake.html">http://www.cmake.org/cmake/help/runningcmake.html</a> for general advice on what you are seeing and how to navigate and change things. The settings you might normally want to change are already presented. You may make changes, then re-configure (using <code>c</code>), so that it gets a chance to make changes that depend on yours and perform more checking. This might require several configuration stages when you are using <code>ccmake</code> - when you are using <code>cmake</code> the iteration is done behind the scenes.</p>
<p>A key thing to consider here is the setting of <code>CMAKE_INSTALL_PREFIX</code>. You will need to be able to write to this directory in order to install GROMACS later, and if you change your mind later, changing it in the cache triggers a full re-build, unfortunately. So if you do not have super-user privileges on your machine, then you will need to choose a sensible location within your home directory for your GROMACS installation. Even if you do have super-user privileges, you should use them only for the installation phase, and never for configuring, building, or running GROMACS!</p>
<p>When <code>cmake</code> or <code>ccmake</code> have completed iterating, the cache is stable and a build tree can be generated, with <code>g</code> in <code>ccmake</code> or automatically with <code>cmake</code>.</p>
<p>You cannot attempt to change compilers after the initial run of <code>cmake</code>. If you need to change, clean up, and start again.</p>
<h3 id="using-cmake-command-line-options"><a href="#using-cmake-command-line-options">Using CMake command-line options</a></h3>
<p>Once you become comfortable with setting and changing options, you may know in advance how you will configure GROMACS. If so, you can speed things up by invoking <code>cmake</code> and passing the various options at once on the command line. This can be done by setting cache variable at the cmake invocation using the <code>-DOPTION=VALUE</code>; note that some environment variables are also taken into account, in particular variables like CC, CXX, FCC (which may be familiar to autoconf users).</p>
<p>For example, the following command line</p>
<pre><code>$ cmake .. -DGMX_GPU=ON -DGMX_MPI=ON -DCMAKE_INSTALL_PREFIX=/home/marydoe/programs</code></pre>
<p>can be used to build with GPUs, MPI and install in a custom location. You can even save that in a shell script to make it even easier next time. You can also do this kind of thing with <code>ccmake</code>, but you should avoid this, because the options set with <code>-D</code> will not be able to be changed interactively in that run of <code>ccmake</code>.</p>
<h3 id="simd-support"><a href="#simd-support">SIMD support</a></h3>
<p>GROMACS has extensive support for detecting and using the SIMD capabilities of many modern HPC CPU architectures. If you are building GROMACS on the same hardware you will run it on, then you don't need to read more about this, unless you are getting configuration warnings you do not understand. By default, the GROMACS build system will detect the SIMD instruction set supported by the CPU architecture (on which the configuring is done), and thus pick the best available SIMD parallelization supported by GROMACS. The build system will also check that the compiler and linker used also support the selected SIMD instruction set and issue a fatal error if they do not.</p>
<p>Valid values are listed below, and the applicable value lowest on the list is generally the one you should choose:</p>
<ol style="list-style-type: decimal">
<li><code>None</code> For use only on an architecture either lacking SIMD, or to which GROMACS has not yet been ported and none of the options below are applicable.</li>
<li><code>SSE2</code> This SIMD instruction set was introduced in Intel processors in 2001, and AMD in 2003. Essentially all x86 machines in existence have this, so it might be a good choice if you need to support dinosaur x86 computers too.</li>
<li><code>SSE4.1</code> Present in all Intel core processors since 2007, but notably not in AMD magny-cours. Still, almost all recent processors support this, so this can also be considered a good baseline if you are content with portability between reasonably modern processors.</li>
<li><code>AVX_128_FMA</code> AMD bulldozer processors (2011) have this. Unfortunately Intel and AMD have diverged the last few years; If you want good performance on modern AMD processors you have to use this since it also allows the reset of the code to use AMD 4-way fused multiply-add instructions. The drawback is that your code will not run on Intel processors at all.</li>
<li><code>AVX_256</code> This instruction set is present on Intel processors since Sandy Bridge (2011), where it is the best choice unless you have an even more recent CPU that supports AVX2. While this code will work on recent AMD processors, it is significantly less efficient than the AVX_128_FMA choice above - do not be fooled to assume that 256 is better than 128 in this case.</li>
<li><code>AVX2_256</code> Present on Intel Haswell processors released in 2013, and it will also enable Intel 3-way fused multiply-add instructions. This code will not work on AMD CPUs.</li>
<li><code>IBM_QPX</code> BlueGene/Q A2 cores have this.</li>
<li><code>Sparc64_HPC_ACE</code> Fujitsu machines like the K computer have this.</li>
</ol>
<p>The CMake configure system will check that the compiler you have chosen can target the architecture you have chosen. <code>mdrun</code> will check further at runtime, so if in doubt, choose the lowest setting you think might work, and see what <code>mdrun</code> says. The configure system also works around many known issues in many versions of common HPC compilers. However, since the options also enable general compiler flags for the platform in question, you can end up in situations where e.g. an <code>AVX_128_FMA</code> binary will just crash on any Intel machine, since the code will try to execute general illegal instructions (inserted by the compiler) before <code>mdrun</code> gets to the architecture detection routines.</p>
<p>A further <code>GMX_SIMD=Reference</code> option exists, which is a special SIMD-like implementation written in plain C that developers can use when developing support in GROMACS for new SIMD architectures. It is not designed for use in production simulations, but if you are using an architecture with SIMD support to which GROMACS has not yet been ported, you may wish to try this option instead of the default <code>GMX_SIMD=None</code>, as it can often out-perform this when the auto-vectorization in your compiler does a good job. And post on the GROMACS mailing lists, because GROMACS can probably be ported for new SIMD architectures in a few days.</p>
<h3 id="cmake-advanced-options"><a href="#cmake-advanced-options">CMake advanced options</a></h3>
<p>The options that are displayed in the default view of <code>ccmake</code> are ones that we think a reasonable number of users might want to consider changing. There are a lot more options available, which you can see by toggling the advanced mode in <code>ccmake</code> on and off with <code>t</code>. Even there, most of the variables that you might want to change have a <code>CMAKE_</code> or <code>GMX_</code> prefix. There are also some options that will be visible or not according to whether their preconditions are satisfied.</p>
<h3 id="helping-cmake-find-the-right-librariesheadersprograms"><a href="#helping-cmake-find-the-right-librariesheadersprograms">Helping CMake find the right libraries/headers/programs</a></h3>
<p>If libraries are installed in non-default locations their location can be specified using the following environment variables:</p>
<ul>
<li><code>CMAKE_INCLUDE_PATH</code> for header files</li>
<li><code>CMAKE_LIBRARY_PATH</code> for libraries</li>
<li><code>CMAKE_PREFIX_PATH</code> for header, libraries and binaries (e.g. <code>/usr/local</code>).</li>
</ul>
<p>The respective <code>include</code>, <code>lib</code>, or <code>bin</code> is appended to the path. For each of these variables, a list of paths can be specified (on Unix, separated with &quot;:&quot;). Note that these are enviroment variables (and not <code>cmake</code> command-line arguments) and in a <code>bash</code> shell are used like:</p>
<pre><code>$ CMAKE_PREFIX_PATH=/opt/fftw:/opt/cuda cmake ..</code></pre>
<p>Alternatively, these variables are also <code>cmake</code> options, so they can be set like <code>-DCMAKE_PREFIX_PATH=/opt/fftw:/opt/cuda</code>.</p>
<p>The <code>CC</code> and <code>CXX</code> environment variables are also useful for indicating to <code>cmake</code> which compilers to use, which can be very important for maximising GROMACS performance. Similarly, <code>CFLAGS</code>/<code>CXXFLAGS</code> can be used to pass compiler options, but note that these will be appended to those set by GROMACS for your build platform and build type. You can customize some of this with advanced options such as <code>CMAKE_C_FLAGS</code> and its relatives.</p>
<p>See also: <a href="http://cmake.org/Wiki/CMake_Useful_Variables#Environment_Variables">http://cmake.org/Wiki/CMake_Useful_Variables#Environment_Variables</a></p>
<h3 id="native-gpu-acceleration"><a href="#native-gpu-acceleration">Native GPU acceleration</a></h3>
<p>If you have the CUDA Toolkit installed, you can use <code>cmake</code> with:</p>
<pre><code>$ cmake .. -DGMX_GPU=ON -DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda</code></pre>
<p>(or whichever path has your installation). In some cases, you might need to specify manually which of your C++ compilers should be used, e.g. with the advanced option <code>CUDA_HOST_COMPILER</code>.</p>
<p>The GPU acceleration has been tested on AMD64/x86-64 platforms with Linux, Mac OS X and Windows operating systems, but Linux is the best-tested and supported of these. Linux running on ARM v7 (32 bit) CPUs also works.</p>
<h3 id="static-linking"><a href="#static-linking">Static linking</a></h3>
<p>Dynamic linking of the GROMACS executables will lead to a smaller disk footprint when installed, and so is the default on platforms where we believe it has been tested repeatedly and found to work. In general, this includes Linux, Windows, Mac OS X and BSD systems. Static binaries take much more space, but on some hardware and/or under some conditions they are necessary, most commonly when you are running a parallel simulation using MPI libraries (e.g. BlueGene, Cray).</p>
<ul>
<li>To link GROMACS binaries statically against the internal GROMACS libraries, set <code>-DBUILD_SHARED_LIBS=OFF</code>.</li>
<li>To link statically against external (non-system) libraries as well, the <code>-DGMX_PREFER_STATIC_LIBS=ON</code> option can be used. Note, that in general <code>cmake</code> picks up whatever is available, so this option only instructs <code>cmake</code> to prefer static libraries when both static and shared are available. If no static version of an external library is available, even when the aforementioned option is <code>ON</code>, the shared library will be used. Also note, that the resulting binaries will still be dynamically linked against system libraries on platforms where that is the default. To use static system libraries, additional compiler/linker flags are necessary, e.g. <code>-static-libgcc -static-libstdc++</code>.</li>
</ul>
<h3 id="portability-aspects"><a href="#portability-aspects">Portability aspects</a></h3>
<p>Here, we consider portability aspects related to CPU instruction sets, for details on other topics like binaries with statical vs dynamic linking please consult the relevant parts of this documentation or other non-GROMACS specific resources.</p>
<p>A GROMACS build will normally not be portable, not even across hardware with the same base instruction set like x86. Non-portable hardware-specific optimizations are selected at configure-time, such as the SIMD instruction set used in the compute-kernels. This selection will be done by the build system based on the capabilities of the build host machine or based on cross-compilation information provided to <code>cmake</code> at configuration.</p>
<p>Often it is possible to ensure portability by choosing the least common denominator of SIMD support, e.g. SSE2 for x86, and ensuring the you use <code>cmake -DGMX_USE_RDTSCP=off</code> if any of the target CPU architectures does not support the <code>RDTSCP</code> instruction. However, we discourage attempts to use a single GROMACS installation when the execution environment is heterogeneous, such as a mix of AVX and earlier hardware, because this will lead to programs (especially <code>mdrun</code>) that run slowly on the new hardware. Building two full installations and locally managing how to call the correct one (e.g. using the module system) is the recommended approach. Alternatively, as at the moment the GROMACS tools do not make strong use of SIMD acceleration, it can be convenient to create an installation with tools portable across different x86 machines, but with separate <code>mdrun</code> binaries for each architecture. To achieve this, one can first build a full installation with the least-common-denominator SIMD instruction set, e.g. <code>-DGMX_SIMD=SSE2</code>, then build separate <code>mdrun</code> binaries for each architecture present in the heterogeneous environment. By using custom binary and library suffixes for the <code>mdrun</code>-only builds, these can be installed to the same location as the &quot;generic&quot; tools installation. Building <a href="#building-only-mdrun">only the <code>mdrun</code> binary</a> is possible by setting the <code>-DGMX_BUILD_MDRUN_ONLY=ON</code> option.</p>
<h3 id="linear-algebra-libraries"><a href="#linear-algebra-libraries">Linear algebra libraries</a></h3>
<p>As mentioned above, sometimes vendor BLAS and LAPACK libraries can provide performance enhancements for GROMACS when doing normal-mode analysis or covariance analysis. For simplicity, the text below will refer only to BLAS, but the same options are available for LAPACK. By default, CMake will search for BLAS, use it if it is found, and otherwise fall back on a version of BLAS internal to GROMACS. The <code>cmake</code> option <code>-DGMX_EXTERNAL_BLAS=on</code> will be set accordingly. The internal versions are fine for normal use. If you need to specify a non-standard path to search, use <code>-DCMAKE_PREFIX_PATH=/path/to/search</code>. If you need to specify a library with a non-standard name (e.g. ESSL on AIX or BlueGene), then set <code>-DGMX_BLAS_USER=/path/to/reach/lib/libwhatever.a</code>.</p>
<p>If you are using Intel MKL for FFT, then the BLAS and LAPACK it provides are used automatically. This could be over-ridden with <code>GMX_BLAS_USER</code>, etc.</p>
<p>On Apple platforms where the Accelerate Framework is available, these will be automatically used for BLAS and LAPACK. This could be over-ridden with <code>GMX_BLAS_USER</code>, etc.</p>
<h3 id="changing-the-names-of-gromacs-binaries-and-libraries"><a href="#changing-the-names-of-gromacs-binaries-and-libraries">Changing the names of GROMACS binaries and libraries</a></h3>
<p>It is sometimes convenient to have different versions of the same GROMACS programs installed. The most common use cases have been single and double precision, and with and without MPI. This mechanism can also be used to install side-by-side multiple versions of <code>mdrun</code> optimized for different CPU architectures, as mentioned previously.</p>
<p>By default, GROMACS will suffix programs and libraries for such builds with <code>_d</code> for double precision and/or <code>_mpi</code> for MPI (and nothing otherwise). This can be controlled manually with <code>GMX_DEFAULT_SUFFIX (ON/OFF)</code>, <code>GMX_BINARY_SUFFIX</code> (takes a string) and <code>GMX_LIBS_SUFFIX</code> (also takes a string). For instance, to set a custom suffix for programs and libraries, one might specify:</p>
<pre><code>cmake .. -DGMX_DEFAULT_SUFFIX=OFF -DGMX_BINARY_SUFFIX=_mod -DGMX_LIBS_SUFFIX=_mod</code></pre>
<p>Thus the names of all programs and libraries will be appended with <code>_mod</code>.</p>
<h2 id="building-gromacs-1"><a href="#building-gromacs-1">Building GROMACS</a></h2>
<p>Once you have configured with <code>cmake</code>, you can build GROMACS. It is expected that the <code>make</code> procedure will always complete successfully, and give few or no warnings. The tests GROMACS makes on the settings you choose are pretty extensive, but there are probably a few cases we have not thought of yet. Search the web first for solutions to problems, but if you need help, ask on gmx-users, being sure to provide as much information as possible about what you did, the system you are building on, and what went wrong. This may mean scrolling back a long way through the output of <code>make</code> to find the first error message!</p>
<p>If you have a multi-core or multi-CPU machine with <code>N</code> processors, then using $ make -j N will generally speed things up by quite a bit. Other build generator systems supported by <code>cmake</code> (e.g. <code>ninja</code>) also work well.</p>
<h3 id="building-only-mdrun"><a href="#building-only-mdrun">Building only mdrun</a></h3>
<p>Past versions of the build system offered &quot;mdrun&quot; and &quot;install-mdrun&quot; targets (similarly for other programs too) to build and install only the mdrun program, respectively. Such a build is useful when the configuration is only relevant for <code>mdrun</code> (such as with parallelization options for MPI, SIMD, GPUs, or on BlueGene or Cray), or the length of time for the compile-link-install cycle is relevant when developing.</p>
<p>This is now supported with the <code>cmake</code> option <code>-DGMX_BUILD_MDRUN_ONLY=ON</code>, which will build a cut-down version of <code>libgromacs</code> and/or the <code>mdrun</code> program (according to whether shared or static). Naturally, now <code>make install</code> installs only those products. By default, mdrun-only builds will default to static linking against GROMACS libraries, because this is generally a good idea for the targets for which an mdrun-only build is desirable. If you re-use a build tree and change to the mdrun-only build, then you will inherit the setting for <code>BUILD_SHARED_LIBS</code> from the old build, and will be warned that you may wish to manage <code>BUILD_SHARED_LIBS</code> yourself.</p>
<h2 id="installing-gromacs"><a href="#installing-gromacs">Installing GROMACS</a></h2>
<p>Finally, <code>make install</code> will install GROMACS in the directory given in <code>CMAKE_INSTALL_PREFIX</code>. If this is a system directory, then you will need permission to write there, and you should use super-user privileges only for <code>make install</code> and not the whole procedure.</p>
<h2 id="getting-access-to-gromacs-after-installation"><a href="#getting-access-to-gromacs-after-installation">Getting access to GROMACS after installation</a></h2>
<p>GROMACS installs the script <code>GMXRC</code> in the <code>bin</code> subdirectory of the installation directory (e.g. <code>/usr/local/gromacs/bin/GMXRC</code>), which you should source from your shell:</p>
<pre><code>$ source /your/installation/prefix/here/bin/GMXRC</code></pre>
<p>It will detect what kind of shell you are running and set up your environment for using GROMACS. You may wish to arrange for your login scripts to do this automatically; please search the web for instructions on how to do this for your shell.</p>
<p>Many of the GROMACS programs rely on data installed in the <code>share/gromacs</code> subdirectory of the installation directory. By default, the programs will use the environment variables set in the <code>GMXRC</code> script, and if this is not available they will try to guess the path based on their own location. This usually works well unless you change the names of directories inside the install tree. If you still need to do that, you might want to recompile with the new install location properly set, or edit the <code>GMXRC</code> script.</p>
<h2 id="testing-gromacs-for-correctness"><a href="#testing-gromacs-for-correctness">Testing GROMACS for correctness</a></h2>
<p>Since 2011, the GROMACS development uses an automated system where every new code change is subject to regression testing on a number of platforms and software combinations. While this improves reliability quite a lot, not everything is tested, and since we increasingly rely on cutting edge compiler features there is non-negligible risk that the default compiler on your system could have bugs. We have tried our best to test and refuse to use known bad versions in <code>cmake</code>, but we strongly recommend that you run through the tests yourself. It only takes a few minutes, after which you can trust your build.</p>
<p>The simplest way to run the checks is to build GROMACS with <code>-DREGRESSIONTEST_DOWNLOAD</code>, and run <code>make check</code>. GROMACS will automatically download and run the tests for you. Alternatively, you can download and unpack the tarball yourself from <a href="http://gerrit.gromacs.org/download/regressiontests-5.0.tar.gz">http://gerrit.gromacs.org/download/regressiontests-5.0.tar.gz</a>, and use the advanced <code>cmake</code> option <code>REGRESSIONTEST_PATH</code> to specify the path to the unpacked tarball, which will then be used for testing. If the above does not work, then please read on.</p>
<p>The regression tests are available from the GROMACS website and ftp site. Once you have downloaded them, unpack the tarball, source <code>GMXRC</code> as described above, and run <code>./gmxtest.pl all</code> inside the regression tests folder. You can find more options (e.g. adding <code>double</code> when using double precision, or <code>-only expanded</code> to run just the tests whose names match &quot;expanded&quot;) if you just execute the script without options.</p>
<p>Hopefully, you will get a report that all tests have passed. If there are individual failed tests it could be a sign of a compiler bug, or that a tolerance is just a tiny bit too tight. Check the output files the script directs you too, and try a different or newer compiler if the errors appear to be real. If you cannot get it to pass the regression tests, you might try dropping a line to the gmx-users mailing list, but then you should include a detailed description of your hardware, and the output of <code>mdrun -version</code> (which contains valuable diagnostic information in the header).</p>
<p>A build with <code>-DGMX_BUILD_MDRUN_ONLY</code> cannot be tested with <code>make check</code> from the build tree, because most of the tests require a full build to run things like <code>grompp</code>. To test such an mdrun fully requires installing it to the same location as a normal build of GROMACS, downloading the regression tests tarball manually as described above, sourcing the correct <code>GMXRC</code> and running the perl script manually. For example, from your GROMACS source directory:</p>
<pre><code>$ mkdir build-normal
$ cd build-normal
$ cmake .. -DCMAKE_INSTALL_PREFIX=/your/installation/prefix/here
$ make -j 4
$ make install
$ cd ..
$ mkdir build-mdrun-only
$ cd build-mdrun-only
$ cmake .. -DGMX_MPI=ON -DGMX_GPU=ON -DGMX_BUILD_MDRUN_ONLY=ON -DCMAKE_INSTALL_PREFIX=/your/installation/prefix/here
$ make -j 4
$ make install
$ cd /to/your/unpacked/regressiontests
$ source /your/installation/prefix/here/bin/GMXRC
$ ./gmxtest.pl all -np 2</code></pre>
<p>If your <code>mdrun</code> program has been suffixed in a non-standard way, then the <code>./gmxtest.pl -mdrun</code> option will let you specify that name to the test machinery. You can use <code>./gmxtest.pl -double</code> to test the double-precision version. You can use <code>./gmxtest.pl -crosscompiling</code> to stop the test harness attempting to check that the programs can be run.</p>
<h2 id="testing-gromacs-for-performance"><a href="#testing-gromacs-for-performance">Testing GROMACS for performance</a></h2>
<p>We are still working on a set of benchmark systems for testing the performance of GROMACS. Until that is ready, we recommend that you try a few different parallelization options, and experiment with tools such as <code>gmx tune_pme</code>.</p>
<h2 id="having-difficulty"><a href="#having-difficulty">Having difficulty?</a></h2>
<p>You are not alone - this can be a complex task! If you encounter a problem with installing GROMACS, then there are a number of locations where you can find assistance. It is recommended that you follow these steps to find the solution:</p>
<ol style="list-style-type: decimal">
<li><p>Read the installation instructions again, taking note that you have followed each and every step correctly.</p></li>
<li><p>Search the GROMACS website and users emailing list for information on the error. Adding &quot;site:https://mailman-1.sys.kth.se/pipermail/gromacs.org_gmx-users&quot; to a Google search may help filter better results.</p></li>
<li><p>Search the internet using a search engine such as Google.</p></li>
<li><p>Post to the GROMACS users emailing list gmx-users for assistance. Be sure to give a full description of what you have done and why you think it did not work. Give details about the system on which you are installing. Copy and paste your command line and as much of the output as you think might be relevant - certainly from the first indication of a problem. In particular, please try to include at least the header from the mdrun logfile, and preferably the entire file. People who might volunteer to help you do not have time to ask you interactive detailed follow-up questions, so you will get an answer faster if you provide as much information as you think could possibly help. High quality bug reports tend to receive rapid high quality answers.</p></li>
</ol>
<h1 id="special-instructions-for-some-platforms"><a href="#special-instructions-for-some-platforms">Special instructions for some platforms</a></h1>
<h2 id="building-on-windows"><a href="#building-on-windows">Building on Windows</a></h2>
<p>Building on Windows using native compilers is rather similar to building on Unix, so please start by reading the above. Then, download and unpack the GROMACS source archive. Make a folder in which to do the out-of-source build of GROMACS. For example, make it within the folder unpacked from the source archive, and call it <code>build-gromacs</code>.</p>
<p>For CMake, you can either use the graphical user interface provided on Windows, or you can use a command line shell with instructions similar to the UNIX ones above. If you open a shell from within your IDE (e.g. Microsoft Visual Studio), it will configure the environment for you, but you might need to tweak this in order to get either a 32-bit or 64-bit build environment. The latter provides the fastest executable. If you use a normal Windows command shell, then you will need to either set up the environment to find your compilers and libraries yourself, or run the <code>vcvarsall.bat</code> batch script provided by MSVC (just like sourcing a bash script under Unix).</p>
<p>With the graphical user interface, you will be asked about what compilers to use at the initial configuration stage, and if you use the command line they can be set in a similar way as under UNIX. You will probably make your life easier and faster by using the new facility to download and install FFTW automatically.</p>
<p>For the build, you can either load the generated solutions file into e.g. Visual Studio, or use the command line with <code>cmake --build</code> so the right tools get used.</p>
<h2 id="building-on-cray"><a href="#building-on-cray">Building on Cray</a></h2>
<p>GROMACS builds mostly out of the box on modern Cray machines, but * you may need to specify the use of static or dynamic libraries (depending on the machine) with <code>-DBUILD_SHARED_LIBS=off</code>, * you may need to set the F77 environmental variable to <code>ftn</code> when compiling FFTW, * you may need to use <code>-DCMAKE_SKIP_RPATH=YES</code>, and * you may need to modify the CMakeLists.txt files to specify the <code>BUILD_SEARCH_END_STATIC</code> target property.</p>
<h2 id="building-on-bluegene"><a href="#building-on-bluegene">Building on BlueGene</a></h2>
<h3 id="bluegeneq"><a href="#bluegeneq">BlueGene/Q</a></h3>
<p>There is currently native acceleration on this platform for the Verlet cut-off scheme. There are no plans to provide accelerated kernels for the group cut-off scheme, but the default plain C kernels will work (slowly).</p>
<p>Only static linking with XL compilers is supported by GROMACS. Dynamic linking would be supported by the architecture and GROMACS, but has no advantages other than disk space, and is generally discouraged on BlueGene for performance reasons.</p>
<p>Computation on BlueGene floating-point units is always done in double-precision. However, mixed-precision builds of GROMACS are still normal and encouraged since they use cache more efficiently. The BlueGene hardware automatically converts values stored in single precision in memory to double precision in registers for computation, converts the results back to single precision correctly, and does so for no additional cost. As with other platforms, doing the whole computation in double precision normally shows no improvement in accuracy and costs twice as much time moving memory around.</p>
<p>You need to arrange for FFTW to be installed correctly, following the above instructions.</p>
<p><code>mpicc</code> is used for compiling and linking. This can make it awkward to attempt to use IBM's optimized BLAS/LAPACK called ESSL (see the section on <a href="#linear-algebra-libraries">linear algebra libraries</a>). Since mdrun is the only part of GROMACS that should normally run on the compute nodes, and there is nearly no need for linear algebra support for mdrun, it is recommended to use the GROMACS built-in linear algebra routines - it is rare for this to run slowly.</p>
<p>The recommended configuration is to use</p>
<pre><code>cmake .. -DCMAKE_TOOLCHAIN_FILE=Platform/BlueGeneQ-static-XL-CXX \
         -DCMAKE_PREFIX_PATH=/your/fftw/installation/prefix \
         -DGMX_MPI=ON \
         -DGMX_BUILD_MDRUN_ONLY=ON
make
make install</code></pre>
<p>which will build a statically-linked MPI-enabled mdrun for the compute nodes. Otherwise, GROMACS default configuration behaviour applies.</p>
<p>It is possible to configure and make the remaining GROMACS tools with the compute-node toolchain, but as none of those tools are MPI-aware and could then only run on the compute nodes, this would not normally be useful. Instead, these should be planned to run on the login node, and a separate GROMACS installation performed for that using the login node's toolchain - not the above platform file, or any other compute-node toolchain.</p>
<p>Note that only the MPI build is available for the compute-node toolchains. The GROMACS thread-MPI or no-MPI builds are not useful at all on BlueGene/Q.</p>
<h3 id="bluegenep"><a href="#bluegenep">BlueGene/P</a></h3>
<p>There is currently no SIMD support on this platform and no plans to add it. The default plain C kernels will work.</p>
<h3 id="fujitsu-primehpc"><a href="#fujitsu-primehpc">Fujitsu PRIMEHPC</a></h3>
<p>This is the architecture of the K computer, which uses Fujitsu <code>Sparc64VIIIfx</code> chips. On this platform, GROMACS 5.0 has accelerated group kernels, no accelerated Verlet kernels, and a custom build toolchain.</p>
<h3 id="intel-xeon-phi"><a href="#intel-xeon-phi">Intel Xeon Phi</a></h3>
<p>GROMACS 5.0 has preliminary support for Intel Xeon Phi. Only symmetric (aka native) mode is supported. GROMACS is functional on Xeon Phi, but it has so far not been optimized to the same level as other architectures have. The performance depends among other factors on the system size, and for now the performance might not be faster than CPUs. Building for Xeon Phi works almost as any other Unix. See the instructions above for details. The recommended configuration is</p>
<pre><code>cmake .. -DCMAKE_TOOLCHAIN_FILE=Platform/XeonPhi
make
make install</code></pre>
<h1 id="tested-platforms"><a href="#tested-platforms">Tested platforms</a></h1>
<p>While it is our best belief that GROMACS will build and run pretty much everywhere, it is important that we tell you where we really know it works because we have tested it. We do test on Linux, Windows, and Mac with a range of compilers and libraries for a range of our configuration options. Every commit in our git source code repository is currently tested on x86 with gcc versions ranging from 4.4 through 4.7, and versions 12 and 13 of the Intel compiler as well as Clang version 3.1 through 3.4. For this, we use a variety of GNU/Linux flavors and versions as well as recent version of Mac OS X. Under Windows we test both MSVC and the Intel compiler. For details, you can have a look at the continuous integration server at <a href="http://jenkins.gromacs.org">http://jenkins.gromacs.org</a>.</p>
<p>We test irregularly on ARM v7, BlueGene/Q, Cray, Fujitsu PRIMEHPC, Google Native Client and other environments, and with other compilers and compiler versions, too.</p>
</body>
</html>
